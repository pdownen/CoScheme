\begin{figure}[t!]
\centering
  
\begin{alignat*}{2}
  \mathit{Value} &\ni{}& V, W
  &::= x
  \mid \lambda x. M
  \mid \Null
  \mid \Cons V \, W
  \mid \q{x}
  \\
  \mathit{EvalCxt} &\ni{}& E
  &::= \hole
  \mid E ~ M
  \mid V ~ E
  \mid \Match E \With \set{\many{P \to N}}
  \mid \Rec x = E
\end{alignat*}
% Operational axioms:
\begin{align*}
  (\beta)
  &&
  (\lambda x. M) ~ V
  &=
  M\subst{x}{V}
  % \\
  % \begin{aligned}
  %   &\Match V \With \\
  %   &\qquad\set{\many[i]{P_i \to N_i}}
  % \end{aligned}
  % &=
  % N_k\subst{BV(P_k)}{\many{W}}
  % &
  % \begin{aligned}
  %   (&\text{if } && V = P_k\subst{BV(P_k)}{\many{W}} \\
  %   &\text{and } &&\forall 1 \leq j < k, \\
  %   &&&\not\exists \many{W'}, V = P_j\subst{BV(P_j)}{\many{W'}})
  % \end{aligned}
  \\
  (\mathit{match})
  &&
  \begin{aligned}
    &\Match V \With \\
    &\qquad
    \begin{aligned}[t]
    \{~ &P \to N; \\
    &\many{P' \to N'}~\}
    \end{aligned}
  \end{aligned}
  &=
  N\subst{\many{x}}{\many{W}}
  &(\text{if } P\subst{\many{x}}{\many{W}} &= V)
  % &(\text{if } \exists \many{W},~ V &= P\subst{BV(P)}{\many{W}})
  \\
  (\mathit{apart})
  &&
  \begin{aligned}
    &\Match V \With \\
    &\qquad
    \begin{aligned}[t]
    \{~ &P \to N; \\
    &\many{P' \to N'}~\}
    \end{aligned}
  \end{aligned}
  &=
  \begin{aligned}
    &\Match V \With \\
    &\qquad \set{\many{P' \to N'}}
  \end{aligned}
  &(\text{if } P &\apart V)
  % &(\text{if}\!\not\exists \many{W},~ V &= P\subst{BV(P)}{\many{W}})
  \\
  (\mathit{rec})
  &&
  \Rec x = V
  &=
  V\subst{x}{(\Rec x = V)}
\end{align*}

% Observational axioms:
% \begin{align*}
%   % \lambda x. (V ~ x)
%   % &=
%   % V
%   % &(\text{if } x &\notin FV(V))
%   % \\
%   (\lambda x. E[x]) ~ M
%   &=
%   E[M]
%   \\
%   E\left[
%     \begin{aligned}
%       &\Match M \With \\
%       &\qquad\set{\many{P \to N}}
%     \end{aligned}
%   \right]
%   &=
%   \begin{aligned}
%     &\Match M \With \\
%     &\qquad \set{\many{P \to E[N]}}
%   \end{aligned}
%   &(\text{if } BV(P) \cap FV(E) = \emptyset)
% \end{align*}

Apartness between patterns and values ($P \apart V$):
\begin{gather*}
  \infer
  {\q{x} \apart V}
  {V \notin \mathit{Variable} \cup \set{\q{x}}}
  \qquad
  \infer
  {\Null \apart V}
  {V \notin \mathit{Variable} \cup \set{\Null}}
  \\[1ex]
  \infer
  {\Cons P ~ P' \apart V}
  {V \notin \mathit{Variable} \cup \set{\Cons W ~ W' \mid W, W' \in \mathit{Value}}}
  \\[1ex]
  \infer
  {\Cons P ~ P' \apart \Cons W ~ W'}
  {P \apart W}
  \qquad
  \infer
  {\Cons P ~ P' \apart \Cons W ~ W'}
  {P' \apart W'}
  % \infer
  % {K ~ P_1 \dots P_n \apart V}
  % {V \neq K ~ W_1 \dots W_n}
  % \qqqquad
  % \infer
  % {K~P_1 \dots P_n \apart K ~ V_1 \dots V_n}
  % {1 \leq j \leq n & P_j \apart V_j}
\end{gather*}

\caption{Untyped equational axioms of the target language.}
\label{fig:target-equality}
\end{figure}

We have defined a translation to a core $\lambda$-calculus, but we still need to specify tools that enable us to confirm that the results of our translation carry their expected meaning.
With that in mind, we can describe equational theories that teach us how to evaluate programs in both the target and the source language and then prove that our translation preserves those properties.  

Since we are in a call-by-value context, we must define our values for both languages. In our target language, values are variables ($x$), lambdas ($\lambda x. ~M$), and patterns ($\Null ~|~ \Cons ~V ~W ~|~ \q{x} $).
We have ordinary evaluation contexts that show us where we can apply our axioms and regular call-by-value $\beta$ reductions.
In addition, we have $\mathit{match}$ and $\mathit{apart}$ that teach us how to deal with pattern matching.
The $\mathit{match}$ selects the matching branch if the first pattern is satisfied, and the $\mathit{apart}$ skips the first pattern if the pattern is not fulfilled.
For the $\mathit{match}$ case, we assume a decomposition of our value $V$ in terms of the pattern.
The $\mathit{rec}$ describes how to unfold a step in a recursive object.

The remainder inference rules tell us how to verify if a pattern is not satisfied.
Those rules make the failure pattern cases explicit.
A variable pattern can not fail, a $\q{x}$ pattern needs exactly a $\q{x}$ value, a $\Null$ pattern needs itself, and a $\Cons$ pattern needs a cons object that fulfills its patterns.


With those rules, we can prove that our translation respects equalities in the target language.
That is, if two terms are equal up to the target equational theory, their translation will also be equal.
This property (\cref{thm:conservative-extension}) tells us that we have a conservative extension \cite{ExpressivePower}, and the proof mainly follows by the fact that our translation is compositional, where we can separate a term and a context inside a translation.


\begin{restatable}[Conservative Extension]{proposition}{thmconservativeextension}
  \label{thm:conservative-extension}
  If $M = N$ in the equational theory of the target
  (\cref{fig:target-equality}), then so too does $\den{M} = \den{N}$.
\end{restatable}

The source language values extend the target language values with new abstractions: templates, extensions, and $\lamstar$'s.
In addition to the axioms of the target language, the source language has many equalities that capture the desired semantics of our operations. Those equalities present properties such as a neutral element for composition ($\varepsilon$), that composition is associative, that we need to commit to a branch with $\Do$, and how to work with our new abstractions.
We also extend our apartness rules to copatterns and contexts.
If it is the case that a pattern is not satisfied in a copattern, then the full copattern is not satisfied.
For contexts, if we know that a copattern is not fulfilled in context, then we see that it will not be fulfilled in a derived context.

\begin{figure}[t!]
\centering

\begin{alignat*}{2}
  % \mathit{TemplateValue} &\ni{}& B_v
  % &::= \varepsilon
  % \mid O_v; B_v
  % \mid \Continue x \to V
  % \\
  % \mathit{ExtensionValue} &\ni{}& O_v
  % &::= O_f
  % \mid O_f; O_v
  % \mid \Nest O_v
  % \mid \Try x \to B_v
  % \\
  \mathit{ExtensionFunc} &\ni{}& F
  &::= Q[x ~ P] ~ O
  \mid \lambda P. O
  \\
  \mathit{Value} &\ni{}& V
  &::= \dots
  \mid \lamstar (F; B)
  \mid \Template B
  \mid \Extension O
  \\
  % \mathit{NonRecTemplate} &\ni{}& B_{nr}
  % &::= O_{nr}; B_{nr}
  % \mid \Else \to M
  % \\
  % \mathit{NonRecExtension} &\ni{}& O_{nr}
  % &::= \varepsilon
  % \mid O_{nr}; O'_{nr}
  % \mid Q[\_] ~ O_{nr}
  % \mid \lambda P. O_{nr}
  % \\
  % &&&\phantom{:=}
  % \mid \Match P \gets M ~ O_{nr}
  % \mid \Nest O
  % \mid \Try x \to B_{nr}
  % \\
  % \mathit{RecCxt} &\ni{}& R
  % &::= \hole
  % \mid R; O
  % \mid O; R
  % \mid Q[x] ~ R
  % \mid \lambda P. R
  % \mid \Match P \gets M ~ O
  % \mid \Try x \to R
\end{alignat*}

Identity, associativity, and annihilation laws of composition:
\begin{align*}
  \varepsilon; O &= O % = O; \varepsilon
  &
  (O_1; O_2); O_3 &= O_1; (O_2; O_3)
  &
  \Do M; O &= \Do M
  \\
  \varepsilon; B &= B
  &
  (O_1; O_2); B &= O_1; (O_2; B)
  &
  \Do M; B &= \Else M
\end{align*}

% Decomposing patterns and copatterns:
% \begin{align*}
%   (Q[x] ~ P) ~ O
%   &=
%   Q[x] ~ (\lambda P. O)
%   &
%   \_ ~ O
%   &=
%   O
%   &
%   \lambda P. O
%   &=
%   \lambda x. (\Match P \gets x ~ O)
% \end{align*}

% Factoring out recursion ($x \neq y$ and $x \notin BV(P)$):
% \begin{align*}
%   \lambda y. (x ~ O)
%   &=
%   x ~ (\lambda y. O)
%   &
%   \Match P \gets M ~ (x ~ O)
%   &=
%   x ~ (\Match P \gets M ~ O)
%   \\
%   (x ~ O); O'
%   &=
%   x ~ (O; O')
%   &
%   O; (x ~ O')
%   &=
%   x ~ (O; O')
% \end{align*}

Instantiating templates and recursive $\lamstar$:
\begin{align*}
  % (\Extension O) ~ V
  % &=
  % \Template{} (O; \Continue x \to (V ~ x))
  % \\
  % (\Template R[Q[x] ~ O]) ~ V
  % &=
  % (\Template R[Q[\_] ~ O\subst{x}{V}]) ~ V
  % \\
  % (\Template R[\Continue x \to M]) ~ V
  % &=
  % (\Template R[\Else \to M\subst{x}{V}]) ~ V
  % \\
  % (\Template B_{nr}) ~ V
  % &=
  % (\Template B_{nr}) ~ W
  % \\
  \lamstar (F; B)
  &=
  (\Template F; B) ~ (\lamstar (F; B))
  \\
  \lambda x. (\lamstar (F; B)) ~ x
  &=
  \lamstar (F; B)
  \\
  (\Template O; B) ~ V
  &=
  (\Extension O) ~ (\Template B) ~ V
  \\
  (\Template \varepsilon) ~ V
  &=
  \mathit{fail}~V
  \\
  (\Template \Continue x \to M) ~ V
  &=
  M\subst{x}{V}
  \\
  (\Extension \Try x \to B) ~ V
  &=
  \Template B\subst{x}{V}
\end{align*}

Pattern and copattern matching:
\begin{align*}
  \Match P \gets V ~ O
  &=
  O\subst{\many{x}}{\many{W}}
  &(\text{if } P\subst{\many{x}}{\many{W}} &= V)
  \\
  \Match{} P \gets V ~ O
  &=
  \varepsilon
  &(\text{if } P &\apart V)
  \\[1ex]
  (\Template{} (\lambda P. \Do M); B) ~ V' ~ V
  &=
  M\subst{\many{x}}{\many{W}}
  &(\text{if } P\subst{\many{x}}{\many{W}} &= V)
  \\
  (\Template{} (\lambda P. O); B) ~ V' ~ V
  &=
  (\Template B) ~ V' ~ V
  &(\text{if } P &\apart V)
  \\[1ex]
  C[(\Template{} (Q[y] = M); B) ~ V]
  &=
  M\subst{y}{V}\subst{\many{x}}{\many{W}}
  &(\text{if } Q\subst{\many{x}}{\many{W}} &= C)
  \\
  C[(\Template{} (Q[y] ~ O); B) ~ V]
  &=
  C[(\Template B) ~ V]
  &(\text{if } Q &\apart C)
  \\[1ex]
  C[\lamstar (Q[y] = M); B]
  &=
  \begin{aligned}[t]
    M
    &\subst{y}{(\lamstar (Q[y] = M); B)}
    \\
    &\subst{\many{x}}{\many{W}}
  \end{aligned}
  &(\text{if } Q\subst{\many{x}}{\many{W}} &= C)
  \\
  C[\lamstar (Q[y] ~ O); \Else M]
  &=
  C[M]
  &(\text{if } Q &\apart C)
\end{align*}

Apartness between copatterns and contexts ($Q \apart C$):
\begin{gather*}
  \infer
  {Q ~ P \apart C ~ V}
  {Q\subst{\many{x}}{\many{W}} = C & P \apart V}
  \qqqquad
  \infer
  {Q ~ P \apart C}
  {Q \apart C}
  \qqqquad
  \infer
  {Q \apart C ~ V}
  {Q \apart C}
\end{gather*}

\caption{Some equalities of copattern extensions.}
\label{fig:source-equality}
\end{figure}


With those equations, we can assert that our translation preserves the desired meaning of each abstraction (\cref{thm:soundness}).
By verifying that our translation preserves equalities on both the source and target language, we know that our translation is sound up to our equational theory.
This is also highlighted by our implementation.
Since we used macros, we are not adding anything substantially new to the language.

\begin{restatable}[Soundness]{proposition}{thmsoundness}
  \label{thm:soundness}
  The equational axioms given in \cref{fig:source-equality} are sound with
  respect to the translation in \cref{fig:translation},
  \begin{align*}
    M &= M' &&\implies & \den{M} &= \den{M'} \\
    B &= B' &&\implies & T\den{B} &= T\den{B'} \\
    O &= O' &&\implies & E\den{O} &= E\den{O'}
  \end{align*}
  up to the equational theory of the target language in
  \cref{fig:target-equality}.
\end{restatable}


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "coscheme"
%%% End:
