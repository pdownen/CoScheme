To increase our familiarity with copatterns in Scheme, let us stress their main traits and introduce our syntax.
One of the entry points of our extension is the macro \scm{define*}.
This macro enables us to declare codata objects through a list of observations.
Each observation is a pair containing a copattern and an outcome.
Every copattern starts with the object's name, which can be followed by an arbitrarily long sequence of patterns. 
The fact that we can create \emph{nested} copatterns allows us to perform equational reasoning. This happens because we can always add one more pattern to the copattern, thus dictating a more specific evaluation context to be matched. The key idea behind observations is that if we find an evaluation context that satisfies our copattern, we can substitute the context with the outcome of the respective observation.

\begin{minted}{scheme}
;; stutter : Stream Nat
(define*
  [ ((stutter n) 'head)        = n]
  [(((stutter n) 'tail) 'head) = n]
  [(((stutter n) 'tail) 'tail) = (stutter (+ n 1))])
\end{minted}

To illustrate this feature, let us materialize a simple example from the ground up.
Still considering the classic stream scenario, we can define streams in terms of their response to the \scm{head} and \scm{tail} destructors. 
So, to create fancier streams, it suffices to specify copatterns containing those destructors.
Let us target a stream that, starting from a number \scm{n}, counts the same number twice before incrementing it. 
Since we want to start from a given number, we need to specify a context that represents this idea: \scm{stutter n}.
We could have selected another initial context, such as \scm{stutter} and \scm{stutter n m}, but those do not describe a context with only a single initial value.

Now, we need to describe the behavior of our destructors.
We can represent our destructors as quoted values.
For example, \scm{(stutter n) 'head} represents an evaluation context where we have a stutter stream, with the state \scm{n}, followed by the destructor \scm{'head}.
What should we do when we have this previous context?
In other words, what should be the outcome of that observation? 
For the \scm{head} destructor, we can return our current state \scm{n}.
However, what should we do with \emph{tail}? We want our second element to be \scm{n}, yet we want our third element to be the successor of \scm{n}.
We want to depict the behavior that we increment the current state in every two elements. 
It is not clear what we should do because the outcome depends on the \emph{next} action after \scm{tail}. 
This is where copatterns take the spotlight.
Since copatterns can be defined with arbitrarily long contexts, we can spell out the desired behavior using multiple observations.
So, when we ask for the second element --- \scm{(((stutter n) 'tail) 'head)} --- we return our current state \scm{n}.
But if we passed over two elements --- \scm{(((stutter n) 'tail) 'tail)} ---,
we can return a new stream with a new state \scm{n + 1}. 

It may not seem to, but this is enough to define our desired stream.
This specific combination of copatterns containing the stream's destructors covers all possible evaluation contexts.
We specified that we return the current state for the first two elements, and if we have a context with at least two \scm{tail} destructors, we replace this context fragment with a new stream with the incremented state.   

Reasoning about the coverage of our copatterns is important since our implementation does not provide coverage analysis.
If we encounter an uncovered case, our implementation emits a runtime error, explaining that this is an uncovered copattern.
Non-total configurations, akin to partial functions, are not always undesirable. They can simplify the development during a prototyping phase, and if the missing case does not make sense, they can be the most semantic thing to do.

This framework is not limited by matching a single value in the initial group.
To illustrate, we can define a stream that intercalates elements from two different streams using a similar configuration, but observing two arguments instead of one.

\adriano{Maybe we can put those examples side by side in a single figure if we decrease the font size}

\begin{minted}{scheme}
;; zigzag : (Stream a, Stream a) -> Stream a
(define*
  [ ((zigzag xs ys) 'head)        = (xs 'head)]
  [(((zigzag xs ys) 'tail) 'head) = (ys 'head)]
  [(((zigzag xs ys) 'tail) 'tail) = (zigzag (xs 'tail) (ys 'tail))])
\end{minted}

However, copatterns are not exclusively used with streams and infinite data.
In particular, we can define a depth-first search on a finite binary tree.
For this goal, we need to specify what should happen in contexts containing leaves and nodes of a tree.
We can create observations that match a specific shape of the input.
Therefore, when we see an evaluation context with a leaf --- \scm{((search ('leaf e)) 'dfs)} ---, we return a singleton, and when we see a node --- \scm{((search ('node l e r)) 'dfs)} ---, we recurse on both children and append their results.
\adriano{Do I need to talk about how DFS works?}

\begin{minted}{scheme}
  (define*
    [((search ('leaf e)) 'dfs) = (list e)]
    [((search ('node l e r)) 'dfs) = (append ((search l) 'dfs) (list e)
                                             ((search r) 'dfs))])
  \end{minted}

Now let us consider an arithmetic evaluator:

\begin{minted}{scheme}
  ;; eval* : Expr -> Number
  (define* eval*
    [(self 'eval ('num n))   = n]
    [(self 'eval ('add l r)) = (+ (self 'eval l) (self 'eval r))])
\end{minted}


Fantastic, it works! 
We have described an evaluator using copatterns matching the possible terms.
One intriguing remark is the role of \scm{self} in this definition.
Here, \scm{self}  is not a keyword, it is a pattern variable that matches the object's name.
For example, we could have defined the number case as: \scm{[(eval* 'eval ('num n))   = n]}.
Another thing to consider is the recursive calls, such as those in the addition case.
The user must pay attention to this since we are working in call-by-value language.
However, what if we wish to add a multiplication, a new operation, to our evaluator? 
We could add one more observation to the previous definition with a copattern matching a \scm{'Mult} term and an outcome similar to the addition case.

Nevertheless, we do not always want to modify existing working code.
This is one of the concerns of the expression problem.
We want to add more operations to our codata type without modifying what we already have.
With that in mind, we could have defined this evaluator differently in a way that exploits one of the key characteristics of our notion of copatterns: \emph{composition}.
We can break down each operation into an individual evaluator who only knows how to deal with that specific operation and obtain the desired evaluator by composing those evaluators.
Since we separated each operation, we must pay attention to recursive calls. To clarify this issue, consider the addition case.
In this case, we have two \scm{self} calls, one for each operand.
This gives the desired result because we use a variable pattern to refer to the evaluator.
If we attempted to write those calls using \scm{eval-add} instead of \scm{self}, we would not have the expected behavior.

\begin{minted}{scheme}
  (define-object eval-num [(self 'eval ('num n)) = n])

  (define-object eval-add
    [(self 'eval ('add l r)) = (+ (self 'eval l) (self 'eval r))])
  
  (define-object eval-mul
    [(self 'eval ('mul l r)) = (* (self 'eval l) (self 'eval r))])
  
  (define eval-arith
    (eval-num 'compose eval-add eval-mul))  
\end{minted}

You might notice that we did not use \scm{define*} in this last definition. \scm{define*} is used to declare closed objects.
In other words, objects with a fixed value for \scm{self}. 
Since we want to combine objects and expect that when we do recursive calls, we do it over the object we get after the composition, we need to work with open objects.
Those objects are not ready for use, but they are malleable since they do not have a fixed value for \scm{self}.
This allows us to blend objects, which refer to an abstract \scm{self}, and then tie the knot by providing a value for \scm{self}.
This last step is done by the \scm{composition} operation, which expects open objects, and it will plug a value for \scm{self} after the whole composition.
The \scm{define-object} is a macro that allows us to define those open objects.

This approach emphasizes our crown jewel: \emph{Composition}.
To be more precise, this is a vertical composition since we are adding more cases to the list of observations.
To help visualize this, you can think that the list of possible observations has one entry per line, and we are adding more lines to that list, thus vertical composition.
Another approach to composition, also supported by our implementation, is to extend some copattern with other copatterns.
In that case, we are extending the size of a specific line, thus creating a horizontal composition.

This modular approach is not only limited to simple arithmetic operations.
We can even expand our current languages with other sophisticated constructs, such as variables.
We can use copatterns to define both the evaluator and the environment containing our variables.
For the environment, we can define an observation that returns the first value after asserting that the first key in the environment is what we are looking for and recursing with the rest of the environment otherwise.
For the variable evaluator, we can perform the variable lookup using our current environment.

\begin{minted}{scheme}
  (define*
    [(lookup ((key1 . val1) . env) key)
      (try-if (eq? key1 key))            = val1]
    [(lookup ((key1 . val1) . env) key) = (lookup env key)])

  (define-object [(eval-var 'eval env ('var x)) = (lookup env x)])
\end{minted}

Okay this is neat.
We just defined one more operation using copatterns.
So we can just compose this new operation with our previous evaluator --- \scm{(define eval-alg-wrong (eval-arith 'compose eval-var))} --- and called the day, right?
Sadly, if we do that, we will not achieve our desired result because the observations in \scm{eval-arith} are not ready to deal with our variable environment. 
We could adapt the \scm{eval-arith} definition to pipe down the environment, but this is the same issue we are trying to avoid.
What we can do is define an evaluator transformer, a codata object that will capture this idea of threading the environment around.
This is precisely the role of \scm{with-environment}, where we use a copattern to adapt an evaluator to pass the environment around.
The \scm{override-lambda*} adds a new observation with a higher precedence.
We use it to ensure that we first try to pass the environment around, and then, if we fail, we try the original observations.
With that, we can use the \scm{'unplug} method to get an open object, reify it with \scm{with-environment}, and then compose it with our variable evaluator, thus obtaining a new evaluator that knows how to deal with both variables and arithmetic expressions.

\begin{minted}{scheme}
  (define (with-environment eval-ext)
    (object
    [(self 'eval env expr)
     (with-self
        (override-lambda* self
         [(_ 'eval sub-expr) = (self 'eval env sub-expr)])
      (try-apply-forget eval-ext 'eval expr))]))

  (define eval-alg*
    ((with-environment (eval-arith 'unplug)) 'compose eval-var))
\end{minted}

However, copattern composition is not only used to declare new operations.
We can use them to implement optimizations.
One compelling example is the constant folding optimization, where we evaluate every possible computation in our reach.
In other words, we leave variables alone and evaluate every other expression that can be reduced to numbers.

We want to encode this idea of only evaluating expressions formed by numbers.
One way to achieve that is to reform each operation instead of performing them directly.
To illustrate, instead of execution \scm{+} with the results of the evaluation of each branch, we can return a new evaluation context where we have \scm{'add}, our reformed operation, in the place of \scm{'eval}.
This enables us to evaluate the operands in this first step and then, in the next step, with a new evaluation context, check if both operands were reduced to numbers before doing the operation.

\begin{minted}{scheme} 
  (define-object eval-add-safe
    [(self 'eval ('add l r))
    = (self 'add (self 'eval l) (self 'eval r))]
    [(self 'add x y)
    (try-if (and (number? x) (number? y)))
    = (+ x y)])

  (define-object eval-mul-safe
    [(self 'eval ('mul l r))
    = (self 'mul (self 'eval l) (self 'eval r))]
    [(self 'mul x y)
    (try-if (and (number? x) (number? y)))
    = (* x y)])

  (define eval-arith-safe
    (eval-num 'compose eval-add-safe eval-mul-safe))
\end{minted}

Nevertheless, we still need to handle variables.
When we attempt to evaluate an expression that has a variable and a complex expression that can be reduced to a number as its operands, we expect a result with the form of \scm{op (var x) (num n)} and not with the shape of \scm{op (var x) n}. 
Since we do not want to bother evaluating the variables, we can define an observation that returns the variable as its outcome.
However, we need to amend the result of the evaluation of our operands.
If we manage to reduce to a number \scm{n}, we need to adapt this result to \scm{(num n)}. 
We can do that by defining a new observation where if we find a reformed operation  --- \scm{try-if (operation? op)} ---, we do this value uplifting.

\begin{minted}{scheme}
  (define-object
    [(leave-variables 'eval ('var x)) = (list 'var x)])

  (define (operation? s)
    (or (equal? s 'add) (equal? s 'mul)))

  (define-object reform-operations*
  [(reform op l r) (try-if (operation? op))
                   (extension
                    [_ (try-if (number? l)) = (reform op (list 'num l) r)]
                    [_ (try-if (number? r)) = (reform op l (list 'num r))]
                    [_                      = (list op l r)])])
\end{minted}

With that machinery in place, we can define our constant folding operation.
We do that by composing our safe evaluator with evaluator that handles variables and our reformer. 

\begin{minted}{scheme}
  (define constant-fold
  (eval-arith-safe 'compose leave-variables reform-operations*))
\end{minted}
