The expression problem~\cite{ExpressionProblem} is a familiar foe.
It is concerned with the intricacy of extending data abstractions with both new forms and operations.
Traditionally, functional languages can easily extend abstractions with more operations, and conversely, object-oriented languages have an advantage in adding more variants to a data type over adding new operations.
The literature presented multiple solutions to the expression problem using various features and spreading on multiple paradigms.

The Visitor pattern~\cite{GangOfFour} is a classic solution in the object-oriented world.
However, we have other options such as~\cite{wehr_javagi_2011}, which brings Java interfaces closer to Haskell's type classes, and~\cite{hutchison_extensibility_2012}, which presents the abstraction of object algebras that are easily integrated into OO languages, since they do not depend upon fancy features.
On the other hand, on the functional paradigm side, we have solutions like~\cite{swierstra_data_2008} and~\cite{keep_nanopass_2013}.
The former utilizes Haskell's type system, specifically type classes, to provide a modular way to construct data types and functions.
However, this approach relies on a type system.
The latter is a compiler framework that provides tools to specify different languages for the compiler passes. The framework achieves this by automatically handling a portion of the mapping between two given entities.

This work presents a novel solution to the expression problem: composable copatterns.
Copatterns~\cite{APTS2013C} are often associated with codata types, but their use is not limited to just that.
Their composition, in particular, allows us to define programs by performing equational reasoning in the evaluation context.
Performing the ``substitution of equals for equals''~\cite{wadler_critique_1987} enhances the predictability and composability of our programs since we can analyze our part code in isolation.

Previous implementations of copatterns are associated with strongly typed languages.
For example, Agda gives the most full-fledged implementation of copatterns in a real system~\cite{ElaboratingDependentCopatterns}.
However, Agda is primarily a proof assistant rather than a general-purpose programming language, and as such, has different concerns than an ordinary functional programmer.
There is also some support for copatterns in OCaml~\cite{LaforgueR17}, but as an unofficial extension that has not been merged into the main compiler.

Rather than just recapping the macro-based definitions of copatterns~\cite{LaforgueR17}, we also use macros, but we focus on providing new methods of extensibility that were not available before and presenting an untyped encoding for copatterns.
To achieve that and fully integrate it into a real, general-purpose programming language, we choose a programmable programming language~\cite{ProgrammablePL} and provide a new language extension as a library~\cite{LanguageLibrary}.
We focus, in particular, on Scheme and Racket, which offers a robust macro system for seamlessly implementing new language features.

Our extension presents three different composition flavors, allowing us to capture some ``design patterns'' used by functional programmers as first-class abstractions.
First, we have \emph{vertical} composition, which permits us to gather a collection of alternative options with failure handling.
Second, we have \emph{horizontal} composition, which permits us to compose a sequence of steps, parameters, matching, or guards.
Third, we have \emph{circular}, which allows us to recurse back on the entire composition itself.

Our primary contributions are organized as follows:
\begin{itemize}
\item \Cref{sec-examples} shows examples of programming with copattern equations in Scheme-like languages, including new forms of program composition --- vertical and horizontal --- that allows us to solve familiar examples of the expression problem~\cite{ExpressionProblem} through a fusion of functional and object-oriented techniques.
\item \Cref{sec-translation} presents a theory for how to translate copatterns into a small core target language --- untyped $\lambda$-calculus with recursion and patterns --- with a local double-barrel transformation reminiscent of selective continuation-passing style transformation.
  Importantly, only the new language constructs are transformed, while existing ones in the target language are unchanged.
\item \Cref{sec-macro} explains how to implement the high-level translation above in real code, and specifically how the implementation differs between Racket and a standard R${}^6$RS-compliant Scheme.
\item \Cref{sec-correctness} demonstrates correctness in terms of an equational theory for reasoning about copattern-matching code in the source language, which is a conservative extension of the target language, and we prove that it is sound with respect to translation.
\end{itemize} 
% The remainder of the article has the following structure: First, we introduce our implementation by explaining meaningful examples (Section \ref{sec-examples}).
% Second, we specify a core language with high-level features representing our implementation. Then we describe a translation into a target $\lambda$-calculus (Section \ref{sec-translation}).
% Third, we scrutinize our implementation, comparing each provided flavor (Section \ref{sec-macro}).
% Fourth, we present the properties of our system (Section \ref{sec-correctness}).
% Last, we explain the details of our optimized racket implementation (Section \ref{sec-opt}).


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "coscheme"
%%% End:
