
To explain the correctness and behavior of composable copattern matching, we give a high-level translation into a conventional $\lambda$-calculus with recursion and pattern matching (given in \cref{fig:target-syntax}).
Our pattern language is modeled after a small common core found among various implementations of Scheme, which includes normal variable wildcards $x$ that can match anything, quoted symbols $\q{x}$, and lists of the form $\Null$ or $(\Cons P \, P')$.
Note that we assume all bound variables $x$ in a pattern are distinct.
% TODO: Deletion Candidate
As shorthand, we write a list of patterns $P_1 ~ P_2 ~ \dots ~ P_n$ for $(\Cons P_1 ~ (\Cons P_2 ~ \dots (\Cons P_n \Null)))$.
To model the patterns found in typed functional languages like ML and Haskell, such as constructor applications $K ~ \many{P}$, we can represent the constructor  as a quoted symbol $\q{K}$ and the application as a list $\q{K} ~ \many{P}$.
% TODO: Deletion Candidate
The patterns' specifics are surprisingly not essential to the main copattern translation and could be extended with other features found in more specific implementations.  

\begin{figure}[t]
\centering
\begin{alignat*}{2}
  % \mathit{Variable} &\ni{}& x, y, z
  % \\
  \mathit{Term} &\ni{}& M, N
  &::= x
  \mid M ~ N
  \mid \lambda x. M
  \mid K
  \mid \Match M \With \set{\many{P \to N}}
  \mid \Rec x = M
  \\
  \mathit{Pattern} &\ni{}& P
  &::= x
  \mid \q{x}
  \mid \Null
  \mid \Cons P \, P'
\end{alignat*}

\caption{Target language: pure $\lambda$-calculus with pattern-matching and recursion.}
\label{fig:target-syntax}
\end{figure}

For simplicity, this translation begins from a small source language with copatterns (given in \cref{fig:source-syntax}) separated into three main syntactic categories:
\begin{itemize}
\item[($M, N$)] \emph{Terms} represent ordinary first-class values as well as applications.
  The new forms of terms are $\lamstar B$, which gives a self-referential copattern-matching object, along with $\Template B$ and $\Extension O$ which include the other two syntactic categories as first-class values.
\item[($B$)] \emph{Templates} represent self-referential code without a fixed self.
  Instead, the ``self'' placeholder remains unbound for now, and it can be instantiated later as $\Template B ~ V$ (where the ``self'' of the template is bound to $V$) or $\lamstar B$ (where the ``self'' of the template is recursively bound to $\lamstar B$).
\item[($O$)] \emph{Extensions} represent extensible code that can be composed together both vertically and horizontally.
  Instead of failing on an unsuccessful match, will try an as-of-yet unspecified ``next'' option.
  To support recursion, the ``self'' placeholder is also unbound for now --- just like with templates --- and can be bound later when the whole object is finished being composed.
  The ``next'' thing to try can be given by the vertical composition with another extension $O; O'$ or a base-case template $O; B$.
  Arbitrary first-class values can passed in as the next option ($V$) and the self object ($W$) as $\Extension O ~ V ~ W$.
\end{itemize}

\begin{figure}[t]
\centering
\small
\begin{alignat*}{2}
  % \mathit{Variable} &\ni{}& x, y, z
  % \\
  \mathit{Term} &\ni{}& M, N
  &::= \dots
  \mid \lamstar B
  \mid \Template B
  \mid \Extension O
  \\
  \mathit{Template} &\ni{}& B
  &::= \varepsilon
  \mid O; B
  \mid \Continue x \to M
  \\
  \mathit{Extension} &\ni{}& O
  &::= \varepsilon
  \mid O; O'
  \mid Q[x] ~ O
  \mid \lambda P.~ O
  % \mid \If M ~ O
  \mid \Match P \gets M ~ O
  % \mid \Nest O
  \mid \Try x \to B
  \\
  \mathit{Copattern} &\ni{}& Q
  &::= \hole
  \mid Q ~ P
  \\
  \mathit{Pattern} &\ni{}& P
  &::= x
  \mid \q{x}
  \mid \Null
  \mid \Cons P \, P'
\end{alignat*}

Syntactic sugar:
\begin{align*}
  \Else M
  &=
  \Continue \_ \to M
  &
  (= M)
  =
  \Do M
  &=
  \Try \_ \to \Else M
  \\
  \If M ~ O
  &=
  \Match \True \gets M ~ O
  &
  (\Let x = M ~ O)
  &=
  \Match x \gets M ~ O
\end{align*}
\caption{Source language: target extended with nested copatterns,
  self-referential objects, recursion templates, and composable extensions.}
\label{fig:source-syntax}
\end{figure}

The remaining new syntax gives ways to define and combine copattern-matching expressions.
Copatterns $Q[x]$ themselves are a subset of contexts, $Q$, surrounding an object internally named $x$.
Two lines separated by a semicolon ($O; O'$) is vertical composition that tries either $O$ or $O'$, and prefixing with a copattern-matching expression ($Q[x] O$) is horizontal composition that tries $Q[x]$ and then $O$.
The $\varepsilon$ represents an empty extension with respect to vertical composition: it immediately refers to the next option.
Smaller special cases of matching include pattern lambdas ($\lambda P. O$) that try to match a new argument against $P$, and pattern guards ($\Match P \gets M ~ O$) that try to match a given expression $M$ against $P$; both of which continue as $O$ if they succeed.
% $\Nest O$ allows for nesting multiple copatterns with a partially applied self object from this point.

Finally, we have the terminators for ending a sequence of matching.
A template can end in the empty $\varepsilon$ (which just fails, because there is no code to handle the case) or a $\Continue x \to M$ which serves as the default ``catch-all'' case.
The parameter $x$ bound by $\Continue x \to M$ is another way to introduce a name for the recursive reference to the object itself at the end of a template  and allows for $M$ to restart from the top and continue the computation.
The syntactic sugar $\Else M$ covers the common case where $M$ give an answer without recursively continuing.
Similarly, an extension can end with $\Try x \to B$. This gives a ``catch-all'' case that runs some other (non-extensible) template $B$.
The parameter $x$ bound by $\Try x \to B$ gives a name to the next option that would have been tried after this one and allows $B$ to explicitly move on to the next option if it needs to.
The syntactic sugar $\Do M$ covers the most common case of $\Try$ which definitively commits to a particular term $M$ to return as the result without trying any further options.
To write examples in a similar style to ML-family languages, we also use the syntactic sugar $(= M)$ with the same meaning, which looks odd out of context but expresses the equational nature of copattern matching when used in examples.

Thus, the full translation from the source (\cref{fig:source-syntax}) to target (\cref{fig:target-syntax}) is given in \cref{fig:translation}.
This translation shares many similarities to continuation-passing style (CPS) translations.
However, we explicitly avoid converting the entire program to CPS.
Notably, every syntactic form for the source language is unchanged; for example, $\den{M~N} = \den{M} ~ \den{N}$.
Instead, the only time we need to introduce an extra parameter is for the two new syntactic categories.
All templates are translated to functions that take a value for the whole object itself to a new version of that object.
Similarly, all extensions are translated to functions that take both a template as the ``base case'' to try next and a value for the whole object itself.
Even though this is dynamically-typed, we can view the type of templates as object transformers and extensions as template transformers:
\begin{align*}
  Object &= \text{some type of function}
  \\
  Template &= Object \to Object'
  \\
  Extension &= Template \to Template'
  = Template \to Object \to Object'
\end{align*}

\begin{figure}[t]
\centering
\small
Translating new terms:  
\begin{align*}
  \den{\lamstar B}
  &=
  (\Rec \mathit{self} = T\den{B} ~ \mathit{self})
  &=_\eta
  (\Rec \mathit{self} = T\den{B} ~ (\lambda x. \mathit{self} ~ x))
  \\
  \den{\Template B}
  &=
  T\den{B}
  \\
  \den{\Extension O}
  &=
  E\den{O}
  \\
  \den{M}
  &=
  \text{by induction}
  &(\text{otherwise})
\end{align*}
Translating templates:
\begin{align*}
  T\den{\varepsilon}
  &=
  \mathit{fail}
  &
  &=_\eta
  \lambda s. \mathit{fail}~s
  \\
  T\den{O; B}
  &=
  E\den{O} ~ T\den{B}
  &
  &=_\eta
  \lambda s. E\den{O} ~ T\den{B} ~ s
  \\
  T\den{\Continue x \to M}
  &=
  \lambda x. \den{M}
\end{align*}

Translating copattern-matching and pattern-matching functions:
\begin{align*}
  E\den{(Q[x] ~ P) ~ O}
  &=
  E\den{Q[x] ~ (\lambda P. O)}
  \\
  E\den{x ~ O}
  &=
  \lambda b. \lambda x. E\den{O} ~ b ~ x
  \\
  E\den{\lambda P. O}
  &=
  E\den{\lambda x. \Match P \gets x ~ O}
  &(\text{if } P \notin \mathit{Variable})
\end{align*}

Translating other extensions:
\begin{align*}
  E\den{\varepsilon}
  &=
  \lambda b. b
  &
  &=_\eta
  \lambda b. \lambda s. b ~ s
  \\
  E\den{O; O'}
  &=
  E\den{O} \comp E\den{O'}
  &
  &=_\eta
  \lambda b. \lambda s. E\den{O} ~ (E\den{O'}~b) ~ s
  \\
  E\den{\lambda x. O}
  &=
  \lambda b. \lambda s. (\lambda x. E\den{O} ~ (\lambda s'. b ~ s' ~ x) ~ s)
  \\
  E\den{\Match P \gets M ~ O}
  &=
  \rlap{$
    \lambda b. \lambda s.
    \Match \den{M} \With \set{P \to E\den{O}~b~s; \_ \to b~s}
  $}
  % \lambda b. \lambda s.
  % \begin{aligned}[t]
  %   &\Match \den{M} \With \\
  %   &\quad
  %   \begin{aligned}[t]
  %     \{~
  %     P &\to E\den{O}~b~s; \\
  %     \_ &\to b~s
  %     ~\}
  %   \end{aligned}
  % \end{aligned}
  \\
  % E\den{\Nest O}
  % &=
  % \lambda b. \lambda s. \Rec s' = E\den{O} ~ (\lambda \_. b ~ s) ~ (\lambda x. s' ~ x)
  % \\
  E\den{\Try x \to B}
  &=
  \lambda x. T\den{B}
\end{align*}
\caption{Translating copattern-based source code to the target language.}
\label{fig:translation}
\end{figure}

The interesting cases for translating terms are the new forms.
$\Template B$ and $\Extension O$ are just translated to their given forms as transformation functions.
With $\lamstar B$, we need to recursively plug its translation in for its self parameter.
Note the one detail that the recursive $\mathit{self}$ is $\eta$-expanded to in this application.
This ensures that $\lambda x. \mathit{self} ~ x$ is treated as a value in a real implementation, and is always safe assuming that $B$ describes a function (non-functional cases of $\lamstar B$ are undefined user error).

For templates and extensions, the terminators $\Continue$ and $\Try$ are translated to plain $\lambda$-abstractions that allow the programmer direct access to their implicit parameters.
% Other cases are specific to each form.
Complex copatterns ($x ~ \many{P_1} P_n ~ O$) are reduced down to a simpler sequence of pattern lambdas ($x ~ \lambda P_1. \dots \lambda P_n. ~ O$), and pattern lambdas ($\lambda P. O$) are reduced down to a simpler non-matching lambda followed by an explicit match guard ($\lambda x. \Match P \gets x ~ O$).

This leaves just the base cases of simple extension forms.
Each time an extension (of form $\lambda b. \lambda s. \dots$) ``fails,'' it calls the given next template with the given self object ($b~s$).
A match guard $\den{\Match P \gets M ~ O}$ will try to match the translation of $M$ against the pattern $P$; the success case continues as $E\den{O}$ with the same next template and self.
A non-matching lambda $\den{\lambda x. O}$ always succeeds (for now), but note that the next template to try on failure has to be changed to include the given argument.
Why?
Because the lambda has already consumed the next argument from its context, it would be gone if, later on, the following operations fail and move on to the next option.
So instead of invoking the given $b$ directly as $b~s'$ (for a potentially different future $s'$), they need to invoke $b$ applied to this argument $x$ as $b~s'~x$.
% Finally, the $\den{\Nest O}$ operation is defined by recursively creating a new value for the self parameter by recursively taking a new snapshot of how the object looks now after all the preceding applications and matchings have already occurred.

In this translation, we also give the $\eta$-reduced forms on the right-hand side when available.
This shows that the empty extension $\varepsilon$ is just the identity function (given the next thing $b$ to try, $\varepsilon$ does nothing and immediately moves on to $b$), and horizontal composition $O; O'$ is just ordinary function composition.


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "coscheme"
%%% End:
